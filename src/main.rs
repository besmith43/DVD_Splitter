use structopt::StructOpt;
use regex::Regex;
use std::path::PathBuf;
use std::process::Command;
use std::sync::atomic::{AtomicBool, Ordering};

/// Blake Smith <besmith43@gmail.com>
///
/// dvd_splitter uses ffmpeg to separate episodes into individual video files from a source video
/// file ripped from a DVD.  It only works for series that have a consistent runtime.
/// 
/// The episodes are named for Plex like this: Fake TV Show - s01e01.mp4
#[derive(StructOpt, Debug)]
#[structopt(name = "dvd_splitter")]
struct Opts {
    /// path to the original file
    #[structopt(short = "i", parse(from_os_str))]
    input_file: PathBuf,
    /// name of the tv series
    #[structopt(short = "s")]
    series_name: String,
    /// number of the season
    #[structopt(short = "n", default_value = "1")]
    season_number: u32,
    /// number of the first episode on the disc
    #[structopt(short = "e", default_value = "1")]
    first_episode: u32,
    /// duration of an average episode (format: hh:mm:ss)
    #[structopt(short = "d")]
    episode_duration: String,
    /// output directory
    #[structopt(short = "o", parse(from_os_str))]
    output_dir: PathBuf,
    /// Debug Mode
    #[structopt(long)]
    debug: bool,
}

struct Episode {
    original_file: PathBuf,
    start_time: u32,
    duration: u32,
    output_filename: String,
}

static ATOMIC_DEBUG: AtomicBool = AtomicBool::new(false);

fn main() {
    let opt = Opts::from_args();

    if opt.debug {
        ATOMIC_DEBUG.store(true, Ordering::Relaxed);
    }

    if !check_ffmpeg_available() {
        panic!("ffmpeg is not in your path");
    }

    let mut episode_duration_seconds: u32 = 0;

    if check_duration_format(&opt.episode_duration) {
        episode_duration_seconds = convert_duration(&opt.episode_duration);
    }

    let original_file_duration = get_video_length(&opt.input_file);

    let num_episodes = original_file_duration / episode_duration_seconds;

    let mut episodes: Vec<Episode> = Vec::new();

    for i in 0..num_episodes {
        debug_println(format!("start job #{}", i));
        episodes.push(Episode {
            original_file: opt.input_file.clone(),
            start_time: i * episode_duration_seconds,
            duration: episode_duration_seconds,
            output_filename: build_filename(&opt.series_name,
                                            convert_number(opt.season_number),
                                            convert_number(opt.first_episode + i),
                                            opt.input_file.extension().unwrap().to_str().unwrap(),
                                            &opt.output_dir),
        });
    }

    run(episodes);
}

fn run(episodes: Vec<Episode>) {
    for episode in episodes {
        debug_println(format!("original file: {}\noutput file: {}\nstart time: {}\nduration: {}", &episode.original_file.to_str().unwrap(), &episode.output_filename, episode.start_time, episode.duration));
        ffmpeg_job(&episode.original_file.to_str().unwrap(), &episode.output_filename, episode.start_time, episode.duration);
    }
}

fn build_filename(series_name: &str, season_number: String, episode_number: String, file_extension: &str, root_dir: &PathBuf) -> String {
    let filename = format!("{}/{} - s{}e{}.{}", &root_dir.to_str().unwrap(), series_name, season_number, episode_number, file_extension);

    debug_println(format!("filename generated by build_filename: {}", &filename));

    filename
}

fn get_video_length(video_file: &PathBuf) -> u32 {
    let probe_info = match ffprobe::ffprobe(&video_file) {
        Ok(info) => info,
        Err(err) => {
            eprintln!("Could not analyze file with ffprobe: {:?}", err);
            panic!();
        }
    };

    probe_info.format.duration.unwrap().parse::<f32>().unwrap().round() as u32
}

// pulled this from https://superuser.com/questions/377343/cut-part-from-video-file-from-start-position-to-end-position-with-ffmpeg
fn ffmpeg_job(input: &str, output: &str, start_time: u32, end_time: u32) {
    Command::new("ffmpeg")
            .arg("-i")
            .arg(input)
            .arg("-ss")
            .arg(start_time.to_string())
            .arg("-t")
            .arg(end_time.to_string())
            .arg("-c")
            .arg("copy")
            .arg(output)
            .output()
            .expect("ffmpeg job failed");
}

// pulled the idea for this from https://stackoverflow.com/questions/35045996/check-if-a-command-is-in-path-executable-as-process
// may need to make it more complicated to search the PATH environment variable
fn check_ffmpeg_available() -> bool {
    let result = match Command::new("ffmpeg").output() {
        Ok(_) => true,
        Err(_e) => false,
    };

    result
}

fn check_duration_format(duration: &str) -> bool {
    let re = Regex::new(r"^\d{2}:\d{2}:\d{2}$").unwrap();
    re.is_match(duration)
}

fn convert_duration(duration: &str) -> u32 {
    let v: Vec<&str> = duration.split(':').collect();

    let temp_str = v[0].to_string();
    let hours: u32 = temp_str.parse::<u32>().unwrap();

    let temp_str = v[1].to_string();
    let minutes = temp_str.parse::<u32>().unwrap();

    let temp_str = v[2].to_string();
    let seconds = temp_str.parse::<u32>().unwrap();

    let total: u32 = hours * 60 * 60 + minutes * 60 + seconds;

    total
}

// this needs to take the season number and turn it into a string that looks like xx
fn convert_number(number: u32) -> String {
    let num_str: String;

    if number < 10 {
        num_str = format!("0{}", number);
    } else {
        num_str = format!("{}", number);
    }

    num_str
}

fn debug_println(message: String) {
    if ATOMIC_DEBUG.load(Ordering::Relaxed) {
        println!("{}", message);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_convert_number() {
        assert_eq!(convert_number(5), "05");
        assert_eq!(convert_number(12), "12");
    }

    #[test]
    fn test_check_ffmpeg_availability() {
        // this test will only work on a computer that has ffmpeg properly in it's system path 
        let result = check_ffmpeg_available();
        assert_eq!(result, true);
    }

    #[test]
    fn test_get_video_length() {
        let original_file = PathBuf::from("./test/original.mp4");

        let result = get_video_length(&original_file);

        assert_eq!(result, 60);
    }

    #[test]
    fn test_check_duration_format() {
        let test_duration = "01:25:05";
        let result = check_duration_format(test_duration);
        assert_eq!(result, true);

        let test_duration = "012505";
        let result = check_duration_format(test_duration);
        assert_ne!(result, true);
    }

    #[test]
    fn test_convert_duration() {
        let test_duration = "01:25:05";

        let duration_seconds = convert_duration(test_duration);
        assert_eq!(duration_seconds, 5105);
    }
}
